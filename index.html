<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Book Grid Explorer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #1a1a1a;
      color: #fff;
    }
    svg {
      width: 100vw;
      height: 100vh;
    }
    .tooltip {
      position: absolute;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      color: white;
      border-radius: 6px;
      pointer-events: none;
      font-size: 13px;
      max-width: 250px;
      display: none;
    }
    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 8px;
      z-index: 10;
    }
    select {
      margin-top: 5px;
      width: 100%;
    }
  </style>
</head>
<body>

<div id="controls">
  <label for="genreSelect">Filter by Genre:</label>
  <select id="genreSelect">
    <option value="All">All</option>
  </select>
</div>

<div class="tooltip" id="tooltip"></div>
<svg id="chart"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const svg = d3.select("#chart");
const tooltip = d3.select("#tooltip");
const genreSelect = document.getElementById("genreSelect");

const width = window.innerWidth;
const height = window.innerHeight;
const margin = {top: 20, right: 20, bottom: 20, left: 20};

let books = [];

// Spiral layout generator (phyllotaxis)
function phyllotaxis(radius) {
  const theta = Math.PI * (3 - Math.sqrt(5)); // golden angle
  return function(i) {
    const r = radius * Math.sqrt(i);
    const a = theta * i;
    return {
      x: r * Math.cos(a),
      y: r * Math.sin(a)
    };
  };
}

// Filtered rendering
function draw(filtered) {

  function highlightCluster(centerBook, bookList, clusterSize = 6) {
  const centerIndex = bookList.findIndex(b => b === centerBook);
  const cluster = [];

  for (let i = -Math.floor(clusterSize / 2); i <= Math.floor(clusterSize / 2); i++) {
    const idx = centerIndex + i;
    if (idx >= 0 && idx < bookList.length && bookList[idx] !== centerBook) {
      cluster.push(bookList[idx]);
    }
  }

  // Highlight the selected and cluster
  svg.selectAll("image")
    .attr("opacity", d => (d === centerBook || cluster.includes(d)) ? 1 : 0.1)
    .attr("stroke", d => (d === centerBook) ? "gold" : cluster.includes(d) ? "lightblue" : null)
    .attr("stroke-width", d => (d === centerBook || cluster.includes(d)) ? 2 : 0);

  // Optional: bring highlighted books to front
  svg.selectAll("image").sort((a, b) => {
    if (a === centerBook) return 1;
    if (cluster.includes(a)) return 1;
    return -1;
  });
}

  svg.selectAll("*").remove();

  const spiral = phyllotaxis(10);
  const centerX = width / 2;
  const centerY = height / 2;

  svg.selectAll("image")
    .data(filtered)
    .join("image")
    .attr("x", (d, i) => spiral(i).x + centerX - 15)
    .attr("y", (d, i) => spiral(i).y + centerY - 22)
    .attr("width", 30)
    .attr("height", 44)
    .attr("xlink:href", d => `https://covers.openlibrary.org/b/isbn/${d.isbn13}-M.jpg`)
    .on("mouseover", (event, d) => {
      tooltip.style("display", "block")
        .html(`
          <strong>${d.title}</strong><br/>
          Author: ${d.author}<br/>
          Genre: ${d.genre}<br/>
          Labels: ${d.labels.join(", ")}
        `);
    })
    .on("mousemove", event => {
      tooltip
        .style("left", (event.pageX + 10) + "px")
        .style("top", (event.pageY + 10) + "px");
    })
    .on("mouseout", () => tooltip.style("display", "none"))
    .on("click", (event, d) => {
    highlightCluster(d, filtered);
  });
}

// Dropdown filter interaction
genreSelect.addEventListener("change", () => {
  const genre = genreSelect.value;
  const filtered = genre === "All" ? books : books.filter(b => b.genre === genre);
  draw(filtered);
});



// Check if cover exists
function checkImage(url) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
    img.src = url;
  });
}

// Load and clean dataset
async function loadData() {
  const data = await d3.json("data/json_output.json");

  // Limit and clean
  const rawBooks = data.filter(d => d.grid_point && d.isbn13).slice(0, 2000);
  const withCovers = await Promise.all(rawBooks.map(async d => {
    const url = `https://covers.openlibrary.org/b/isbn/${d.isbn13}-M.jpg`;
    const hasCover = await checkImage(url);
    return hasCover ? d : null;
  }));

  books = withCovers.filter(Boolean);

  // Populate filter
  const genres = Array.from(new Set(books.map(d => d.genre))).sort();
  genreSelect.innerHTML = '<option value="All">All</option>';
  genres.forEach(g => {
    const option = document.createElement("option");
    option.value = g;
    option.textContent = g;
    genreSelect.appendChild(option);
  });

  draw(books);
}

loadData();
</script>

</body>
</html>


